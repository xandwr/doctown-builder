// Pipeline Phase 7: Package outputs into .docpack file
// Creates a .docpack (zip) containing all generated artifacts

use std::fs::File;
use std::io::Write;
use std::path::Path;
use zip::write::{SimpleFileOptions, ZipWriter};
use zip::CompressionMethod;

/// Configuration for packaging
#[derive(Debug, Clone)]
pub struct PackageConfig {
    // Reserved for future configuration options
    _reserved: (),
}

impl Default for PackageConfig {
    fn default() -> Self {
        Self { _reserved: () }
    }
}

/// Result of packaging
#[derive(Debug, Clone)]
#[allow(unused)]
pub struct PackageResult {
    pub output_path: String,
    pub files_included: usize,
    pub total_size_bytes: usize,
}

/// Package all output files into a .docpack file
pub fn package_outputs(
    input_name: &str,
    output_dir: &str,
    _config: &PackageConfig,
) -> Result<PackageResult, Box<dyn std::error::Error>> {
    // Determine output filename inside the provided output directory
    let input_path = Path::new(input_name);
    let base_name = input_path
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("output");

    let final_name = if input_name.starts_with("http") {
        input_name
            .split('/')
            .last()
            .unwrap_or(base_name)
            .trim_end_matches(".git")
            .to_string()
    } else {
        base_name.to_string()
    };

    // Ensure the output directory exists
    let output_path = Path::new(output_dir);
    if !output_path.exists() {
        std::fs::create_dir_all(output_path)?;
    }

    let docpack_path = output_path.join(format!("{}.docpack", final_name));

    // Create the zip file
    let file = File::create(&docpack_path)?;
    let mut zip = ZipWriter::new(file);

    let options = SimpleFileOptions::default().compression_method(CompressionMethod::Deflated);

    let mut files_included = 0;
    let mut total_size = 0;

    // Define files to include in the package (using temp files)
    let files_to_package = vec![
        (
            format!("{}/.temp-graph.json", output_dir),
            "graph.json".to_string(),
        ),
        (
            format!("{}/.temp-documentation.json", output_dir),
            "documentation.json".to_string(),
        ),
    ];

    // Add each file to the zip
    for (source_path, archive_name) in &files_to_package {
        if let Ok(content) = std::fs::read(source_path) {
            zip.start_file(archive_name, options)?;
            zip.write_all(&content)?;
            total_size += content.len();
            files_included += 1;
        } else {
            eprintln!("   ⚠️  Warning: Could not read {} (skipping)", source_path);
        }
    }

    // Add metadata file
    let metadata = generate_metadata(input_name, files_included, total_size);
    zip.start_file("metadata.json", options)?;
    zip.write_all(metadata.as_bytes())?;
    files_included += 1;

    // Add README
    let readme = generate_readme(input_name);
    zip.start_file("README.md", options)?;
    zip.write_all(readme.as_bytes())?;
    files_included += 1;

    zip.finish()?;

    // Clean up temporary files
    for (source_path, _) in &files_to_package {
        if Path::new(source_path).exists() {
            let _ = std::fs::remove_file(source_path);
        }
    }

    Ok(PackageResult {
        output_path: docpack_path.to_string_lossy().to_string(),
        files_included,
        total_size_bytes: total_size,
    })
}

/// Generate the .docpack filename from input name
// NOTE: docpack path is now constructed inside `package_outputs` using the
// provided `output_dir`, so the previous helper is no longer needed.

/// Generate metadata JSON
fn generate_metadata(input_name: &str, files: usize, size: usize) -> String {
    let metadata = serde_json::json!({
        "version": "1.0",
        "generator": "Doctown Builder",
        "source": input_name,
        "generated_at": chrono::Utc::now().to_rfc3339(),
        "files_included": files,
        "total_size_bytes": size,
        "format": "docpack",
        "contents": {
            "graph.json": "The complete code graph with nodes (functions, types, modules) and edges (relationships)",
            "documentation.json": "LLM-generated documentation including symbol summaries, module overviews, and architecture overview"
        }
    });

    serde_json::to_string_pretty(&metadata).unwrap_or_default()
}

/// Generate README content
fn generate_readme(input_name: &str) -> String {
    format!(
        r#"# Docpack: {}

This is a Docpack file generated by Doctown Builder.

## Contents

- `graph.json` - The complete code graph with all symbols and relationships
- `documentation.json` - AI-generated documentation and insights
- `metadata.json` - Package metadata and generation info

## Graph Structure

The graph contains:
- **Nodes**: Functions, types, modules, files, and semantic clusters
- **Edges**: Relationships like function calls, imports, type references
- **Metrics**: Complexity, fan-in/fan-out, public API detection

## Using This Package

The JSON files can be consumed by:
- Documentation viewers
- IDE plugins
- Static analysis tools
- Custom visualization tools

## Enriched Insights

This package includes AI-generated insights that combine:
- Cyclomatic complexity analysis
- Fan-in/fan-out metrics (how connected each symbol is)
- Public API surface detection
- Semantic clustering of related code
- Natural language explanations of what code does

Example insights you'll find:
> "This function has high fan-in (17 callers) and moderate complexity,
> indicating it is a central dependency in the module. Changes should be
> made with caution, as this function forms a key integration point."

---
Generated from: {}
Generated at: {}
"#,
        Path::new(input_name)
            .file_name()
            .and_then(|s| s.to_str())
            .unwrap_or(input_name),
        input_name,
        chrono::Utc::now().to_rfc3339()
    )
}
