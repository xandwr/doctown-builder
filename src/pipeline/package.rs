// Pipeline Phase 7: Package outputs into .docpack file
// Creates a .docpack (zip) containing all generated artifacts

use std::fs::File;
use std::io::Write;
use std::path::Path;
use zip::write::{SimpleFileOptions, ZipWriter};
use zip::CompressionMethod;

/// Configuration for packaging
#[derive(Debug, Clone)]
pub struct PackageConfig {
    // Reserved for future configuration options
    _reserved: (),
}

impl Default for PackageConfig {
    fn default() -> Self {
        Self { _reserved: () }
    }
}

/// Result of packaging
#[derive(Debug, Clone)]
#[allow(unused)]
pub struct PackageResult {
    pub output_path: String,
    pub files_included: usize,
    pub total_size_bytes: usize,
}

/// Package all output files into a .docpack file
pub fn package_outputs(
    input_name: &str,
    output_dir: &str,
    _config: &PackageConfig,
) -> Result<PackageResult, Box<dyn std::error::Error>> {
    // Determine output filename
    let docpack_name = generate_docpack_name(input_name);
    let docpack_path = Path::new(&docpack_name);

    // Create the zip file
    let file = File::create(docpack_path)?;
    let mut zip = ZipWriter::new(file);

    let options = SimpleFileOptions::default().compression_method(CompressionMethod::Deflated);

    let mut files_included = 0;
    let mut total_size = 0;

    // Define files to include in the package (using temp files)
    let files_to_package = vec![
        (
            format!("{}/.temp-graph.json", output_dir),
            "graph.json".to_string(),
        ),
        (
            format!("{}/.temp-documentation.json", output_dir),
            "documentation.json".to_string(),
        ),
    ];

    // Add each file to the zip
    for (source_path, archive_name) in &files_to_package {
        if let Ok(content) = std::fs::read(source_path) {
            zip.start_file(archive_name, options)?;
            zip.write_all(&content)?;
            total_size += content.len();
            files_included += 1;
        } else {
            eprintln!("   ⚠️  Warning: Could not read {} (skipping)", source_path);
        }
    }

    // Add metadata file
    let metadata = generate_metadata(input_name, files_included, total_size);
    zip.start_file("metadata.json", options)?;
    zip.write_all(metadata.as_bytes())?;
    files_included += 1;

    // Add README
    let readme = generate_readme(input_name);
    zip.start_file("README.md", options)?;
    zip.write_all(readme.as_bytes())?;
    files_included += 1;

    zip.finish()?;

    // Clean up temporary files
    for (source_path, _) in &files_to_package {
        if Path::new(source_path).exists() {
            let _ = std::fs::remove_file(source_path);
        }
    }

    Ok(PackageResult {
        output_path: docpack_name.clone(),
        files_included,
        total_size_bytes: total_size,
    })
}

/// Generate the .docpack filename from input name
fn generate_docpack_name(input_name: &str) -> String {
    let input_path = Path::new(input_name);

    // Get the filename without extension
    let base_name = input_path
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("output");

    // If input was a URL, extract repo name
    let final_name = if input_name.starts_with("http") {
        // Extract repo name from URL (e.g., "user/repo.git" -> "repo")
        input_name
            .split('/')
            .last()
            .unwrap_or(base_name)
            .trim_end_matches(".git")
    } else {
        base_name
    };

    format!("output/{}.docpack", final_name)
}

/// Generate metadata JSON
fn generate_metadata(input_name: &str, files: usize, size: usize) -> String {
    let metadata = serde_json::json!({
        "version": "1.0",
        "generator": "Doctown Builder",
        "source": input_name,
        "generated_at": chrono::Utc::now().to_rfc3339(),
        "files_included": files,
        "total_size_bytes": size,
        "format": "docpack",
        "contents": {
            "graph.json": "The complete code graph with nodes (functions, types, modules) and edges (relationships)",
            "documentation.json": "LLM-generated documentation including symbol summaries, module overviews, and architecture overview"
        }
    });

    serde_json::to_string_pretty(&metadata).unwrap_or_default()
}

/// Generate README content
fn generate_readme(input_name: &str) -> String {
    format!(
        r#"# Docpack: {}

This is a Docpack file generated by Doctown Builder.

## Contents

- `graph.json` - The complete code graph with all symbols and relationships
- `documentation.json` - AI-generated documentation and insights
- `metadata.json` - Package metadata and generation info

## Graph Structure

The graph contains:
- **Nodes**: Functions, types, modules, files, and semantic clusters
- **Edges**: Relationships like function calls, imports, type references
- **Metrics**: Complexity, fan-in/fan-out, public API detection

## Using This Package

The JSON files can be consumed by:
- Documentation viewers
- IDE plugins
- Static analysis tools
- Custom visualization tools

## Enriched Insights

This package includes AI-generated insights that combine:
- Cyclomatic complexity analysis
- Fan-in/fan-out metrics (how connected each symbol is)
- Public API surface detection
- Semantic clustering of related code
- Natural language explanations of what code does

Example insights you'll find:
> "This function has high fan-in (17 callers) and moderate complexity,
> indicating it is a central dependency in the module. Changes should be
> made with caution, as this function forms a key integration point."

---
Generated from: {}
Generated at: {}
"#,
        Path::new(input_name)
            .file_name()
            .and_then(|s| s.to_str())
            .unwrap_or(input_name),
        input_name,
        chrono::Utc::now().to_rfc3339()
    )
}
